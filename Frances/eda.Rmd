---
title: "EDA"
author: "Frances Hung"
date: "3/30/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stringr)
```

## Reading in Data

We read in the MWM data and connectome matrices:
```{r cars}
mwmlong<-read.csv("../data/MWMlong.csv")
```


```{r}
filePaths <- list.files("../data/Connectomes",
                        "\\.csv$", full.names = TRUE)
connectome_matlist <- lapply(filePaths,function(x) read.csv(x,header=FALSE) %>% as.matrix())
```

## Helper Functions

Binarizing Matrix Function:
```{r}
# takes matrix (matr) and binarizes each element 
# based on a threshold (strict less than)

binarize_matrix <- function(matr, threshold) {
  
  for (i in 1:length(matr)) {
    matr[[i]] <- ifelse(matr[[i]] < threshold, 0, 1)
  }
  
  return(matr)
}

```

Difference in Networks (binarized matrices)

```{r}
# returns vector of number of edge deletions and additions needed for 
# binarized matr_1 to become binarized matr_2

network_diffs <- function(matr_1,matr_2,threshold) {
  
  # frequency matrix of -1,0,1 resulting from difference of bin. matrices
  diff_freq_matr <- binarize_matrix(matr_2,threshold) - 
    binarize_matrix(matr_1,threshold)
  
  add=sum(diff_freq_matr==1)
  del=sum(diff_freq_matr==-1)
  
  return(c(del,add))
}
```

## Indexing Matrices by Runno
```{r}

# create list of identifiers corresponding to list of connectomes
regexp <- "N[[:digit:]]{5}"
matrix_labels <- lapply(filePaths,function(x) str_extract(x,regexp)) %>% unlist()

# takes vector of runnos and finds corresponding matrices

find_connect <- function(runnos) {
  
  idxs <- which(matrix_labels %in% runnos)
  
  if (length(idxs) == 0) {
    print("No matches")
    return(0)
  }
  
  return(connectome_matlist[idxs])
}

```

Gibbs Sampler
```{r}
n=3
R=10
pis=runif(n)
data=array(sample(c(0,1),R^2*n,replace = TRUE),dim=c(R,R,n))
iter=100
##Initialization
Cs=rep(0,n)
B0=matrix(0,10,10)
B1=matrix(1,10,10)
Psi=matrix(.999,2,2)
Cs_save=matrix(0,n,iter)
for(t in 1:iter){
  # Update C
  for (i in 1:n) {
    p1=Psi[2,]^network_diffs(data[,,i],B1,0.5)
    p1=p1[1]*p1[2]*pis[i]
    p0=Psi[1,]^network_diffs(data[,,i],B0,0.5)
    p0=p0[1]*p0[2]*(1-pis[i])
    Cs[i]=sample(c(0,1),1,prob=c(p0,p1))
  }
  # Update Psi
  add_B0=0
  del_B0=0
  add_B1=0
  del_B1=0
  for (i in 1:n) {
    if (Cs[i]==0){
      del_B0=del_B0+network_diffs(data[,,i],B0,0.5)[1]
      add_B0=add_B0+network_diffs(data[,,i],B0,0.5)[2]
    }
    else{
      del_B1=del_B1+network_diffs(data[,,i],B1,0.5)[1]
      add_B1=add_B1+network_diffs(data[,,i],B1,0.5)[2]
    }
  }
  Psi[1,1]=rbeta(1,del_B0+1,1)
  Psi[1,2]=rbeta(1,add_B0+1,1)
  Psi[2,1]=rbeta(1,del_B1+1,1)
  Psi[2,2]=rbeta(1,add_B1+1,1)
  # Update B0
  for (j in 1:R) {
    for (l in 1:R) {
      p=Psi[1,]^c(sum(data[j,l,Cs==0]==1),sum(data[j,l,Cs==0]==0))
      B0[j,l]=sample(c(0,1),1,prob = p)
      p=Psi[2,]^c(sum(data[j,l,Cs==1]==1),sum(data[j,l,Cs==1]==0))
      B1[j,l]=sample(c(0,1),1,prob = p)
    }
  }
  Cs_save[,t]=Cs
}
```

